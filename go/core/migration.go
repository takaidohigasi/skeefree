package core

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/github/skeefree/go/gh"
)

type MigrationStatus string

const (
	MigrationStatusProposed  MigrationStatus = "proposed"  // generated by skeefree in response to finding a PR, not approved yet
	MigrationStatusQueued    MigrationStatus = "queued"    // approved by database team, enqueued to run
	MigrationStatusReady     MigrationStatus = "ready"     // scheduled to run next; awaiting execution by the next handler
	MigrationStatusCancelled MigrationStatus = "cancelled" // cancelled by database team, for whatever reason
	MigrationStatusRunning   MigrationStatus = "running"   // being executed right now
	MigrationStatusFailed    MigrationStatus = "failed"    // execution failed
	MigrationStatusComplete  MigrationStatus = "complete"  // execution success
	MigrationStatusUnknown   MigrationStatus = "unknown"   // catch-all; to find flaws in logic
)

type MigrationStrategy string

const (
	MigrationStrategyManual  MigrationStrategy = "manual"  // A human will run this
	MigrationStrategyDirect  MigrationStrategy = "direct"  // skeefree to issue a direct query on the master(s)
	MigrationStrategyGhost   MigrationStrategy = "gh-ost"  // Ask gh-ost to run the migration
	MigrationStrategyRolling MigrationStrategy = "rolling" // Migrate on each replica with SQL_LOB_BIN=0, failvoer master
)

var (
	beautifySuggestionRegexp = regexp.MustCompile(`[\n][ \t]+`)
)

const dropTableTimeFormat = "20060102150405"

type Migration struct {
	Id          int64                          `json:"id"`
	Cluster     *gh.MySQLCluster               `json:"cluster"`
	Shard       string                         `json:"shard"`
	Repo        *Repository                    `json:"repo"`
	PR          *PullRequest                   `json:"pr"`
	PRStatement *PullRequestMigrationStatement `json:"pr_statement"`
	Strategy    MigrationStrategy              `json:"strategy"`
	Canonical   string                         `json:"canonical"`
	TableName   string                         `json:"table_name"`
	Alter       string                         `json:"alter"` // ALTER statement (anything that follows `ALTER (TABLE|DATABASE) <tbl|db>`), or empty if this isn't a ALTER operation
	Suggestion  string                         `json:"suggestion"`
	Token       string                         `json:"token"`
	TokenHint   string                         `json:"token_hint"`
	Status      MigrationStatus                `json:"status"`
}

func NewMigration(cluster *gh.MySQLCluster, shard string, repo *Repository, pr *PullRequest, prStatement PullRequestMigrationStatement, strategy MigrationStrategy) *Migration {
	return &Migration{
		Cluster:     cluster,
		Shard:       shard,
		Repo:        repo,
		PR:          pr,
		PRStatement: &prStatement,
		Strategy:    strategy,
		Token:       "",
		Status:      MigrationStatusProposed,
	}
}

func NewEmptyMigration() *Migration {
	return &Migration{
		Cluster:     &gh.MySQLCluster{},
		Repo:        &Repository{},
		PR:          &PullRequest{},
		PRStatement: &PullRequestMigrationStatement{},
	}
}

// GetMigrationType is a convenience method to get the same from the member `prStatement`
func (migration *Migration) GetMigrationType() MigrationType {
	return migration.PRStatement.GetMigrationType()
}

func (migration *Migration) EvalClusterName() string {
	if migration.Shard == "" {
		if migration.Cluster != nil && migration.Cluster.Name != "" {
			return migration.Cluster.Name
		}
		return migration.Repo.MySQLCluster
	}
	return fmt.Sprintf("%s-%s", migration.Repo.MySQLCluster, migration.Shard)
}

func (migration *Migration) Evaluate() error {

	migrationEvalMap := map[MigrationType](func() error){
		AlterDatabaseMigrationType: migration.evalAlterDatabase,
		CreateTableMigrationType:   migration.evalCreateTable,
		DropTableMigrationType:     migration.evalDropTable,
		AlterTableMigrationType:    migration.evalAlterTable,
	}
	if f, ok := migrationEvalMap[migration.GetMigrationType()]; ok {
		return f()
	}
	return fmt.Errorf("Evaluation unsupported for %v", migration.GetMigrationType())
}

func beautifySuggestion(suggestion string) (result string) {
	suggestion = strings.TrimSpace(suggestion)
	suggestion = beautifySuggestionRegexp.ReplaceAllString(suggestion, "\n")
	suggestion = fmt.Sprintf("\n```\n%s\n```\n", suggestion)
	return suggestion
}

func (migration *Migration) PrettySuggestion() string {
	return beautifySuggestion(migration.Suggestion)
}

func (migration *Migration) evalAlterDatabase() error {
	databaseName, alter, err := dissectAlterDatabaseStatement(migration.PRStatement.Statement)
	if err != nil {
		return err
	}
	if databaseName != migration.Repo.MySQLSchema {
		return fmt.Errorf("ALTER DATABASE only supported on repo's schema: %s. Given: %s", migration.Repo.MySQLSchema, databaseName)
	}
	migration.TableName = ""
	migration.Alter = alter
	migration.Canonical = fmt.Sprintf("ALTER DATABASE %s", databaseName)
	migration.Suggestion = fmt.Sprintf(`
		# Run in shell:
		mysql -h "%s" -P "%d" "%s"

		%s
	`, migration.Cluster.RWName, migration.Cluster.Port, migration.Repo.MySQLSchema, migration.PRStatement.Statement)
	return nil
}

func (migration *Migration) evalCreateTable() error {
	tableName, err := dissectCreateTableStatement(migration.PRStatement.Statement)
	if err != nil {
		return err
	}
	migration.TableName = tableName
	migration.Canonical = fmt.Sprintf("CREATE TABLE %s", tableName)
	migration.Suggestion = fmt.Sprintf(`
		# Run in shell:
		mysql -h "%s" -P "%d" "%s"

		%s
	`, migration.Cluster.RWName, migration.Cluster.Port, migration.Repo.MySQLSchema, migration.PRStatement.Statement)
	return nil
}

func (migration *Migration) evalDropTable() error {
	tableName, err := dissectDropTableStatement(migration.PRStatement.Statement)
	if err != nil {
		return err
	}

	dummyDropTableName := GetSafeTableNameWithSuffix(fmt.Sprintf("_%s_%s", time.Now().Format(dropTableTimeFormat), tableName), "DRP")
	migration.PRStatement.Statement = fmt.Sprintf("RENAME TABLE %s TO %s", tableName, dummyDropTableName)
	migration.TableName = tableName
	migration.Canonical = fmt.Sprintf("DROP TABLE %s", tableName)
	migration.Suggestion = fmt.Sprintf(`
		# Run in shell:
		mysql -h "%s" -P "%d" "%s"

		%s
	`, migration.Cluster.RWName, migration.Cluster.Port, migration.Repo.MySQLSchema, migration.PRStatement.Statement)
	return nil
}

func (migration *Migration) evalAlterTable() error {
	tableName, alter, hasDropColumn, err := dissectAlterTableStatement(migration.PRStatement.Statement)
	if err != nil {
		return err
	}
	alter = strings.TrimRight(alter, ";")
	migration.TableName = tableName
	migration.Alter = alter
	migration.Canonical = fmt.Sprintf("ALTER TABLE %s", tableName)
	notes := ""
	if hasDropColumn {
		notes = "### NOTE: found DROP COLUMN"
	}
	bashEscapedAlter := strings.ReplaceAll(alter, `'`, `'"'"'`)
	migration.Suggestion = fmt.Sprintf(`
		# %s
		# Run on utility box:
		command-to-run-gh-ost -c "%s" -s "%s" -t "%s" -d '%s' "$@"
	`, notes, migration.EvalClusterName(), migration.Repo.MySQLSchema, tableName, bashEscapedAlter)
	return nil
}

func (migration *Migration) BriefDescription() string {
	return fmt.Sprintf("%s/%s: %s", migration.Status, migration.Strategy, migration.Canonical)
}

func (migration *Migration) BriefDescriptionMarkdown() string {
	return fmt.Sprintf("%s/%s: `%s`", migration.Status, migration.Strategy, migration.Canonical)
}

func (migration *Migration) DescriptionMarkdown() string {
	return fmt.Sprintf("%s/%s: `%s`, `%s/%s`", migration.Status, migration.Strategy, migration.Canonical, migration.Cluster.Name, migration.Repo.MySQLSchema)
}
